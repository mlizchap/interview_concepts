// hash table implementation

class HashTable {
    constructor(size){
      this.data = new Array(size); // creates an array of arrays consisting of the key/value pairs
    }
  
    _hash(key) { /* underscore shows that this should be a private method */
      let hash = 0;
      for (let i =0; i < key.length; i++) {
          hash = (hash + key.charCodeAt(i) * i) % this.data.length /* for each character of the key, generates a number.  Multiplied by i to make the number unique.  The modulo of the length is used to make sure that the number falls within the length of the data array */
      }
      return hash;
    }
    
    // insertion
    set(key, value) {
      let address = this._hash(key);
  
      /* if there is nothing in the address space */
      if (!this.data[address]) { 
        this.data[address] = [];
        this.data[address].push([key, value])
      } 
      
      /* if there is a collision (this is an item in the address space generated by the hash function) */
      this.data[address].push([key, value])
  
      return this.data
    }
  
    // lookup
    get(key) {
      let address = this._hash(key);
      const currentBucket = this.data[address];
      if (currentBucket) { /* if there is an item/items in the bucket */
        
        /* run a for loop in case there are collisions and there is more than one item in the slot */
        for (let i = 0; i < currentBucket.length; i++) {
          if (currentBucket[i][0] === key) { /* if the first value of the item is equal to the key */
            return currentBucket[i][1]; /* returns the corresponding value of the key(the second item in the array) */
          }
        }
      }
      
      return undefined; /* if there is nothing in the bucket */
    }
  
    // for iterating through the hash table
    keys() {
      const keysArray = [];
  
      /* loops through all of item spaces (shelves) */
      for (let i = 0; i < this.data.length; i++) {
        if (this.data[i]) { /* if there is something in the memory space */
          /*
            Since for each item we create a new array with another array pushed in, each item is an array of an array. 
              - the first 0 removes the outer array
              - the second 0 grabs the key 
          */
          keysArray.push(this.data[i][0][0]) 
        }
      }
  
      return keysArray; // returns an array of all of the keys
    }
  }
  
  const myHashTable = new HashTable(50);
  myHashTable._hash('grapes');
  myHashTable.set('grapes', 10000);
  myHashTable.get('grapes');
  myHashTable.set('apples', 9);
  myHashTable.get('apples');
  myHashTable.set('oranges', 2);
  console.log(myHashTable.keys());